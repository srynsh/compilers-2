% LaTeX Template for short student reports.
% Citations should be in bibtex format and go in references.bib
\documentclass[a4paper, 11pt]{article}
\usepackage[top=3cm, bottom=3cm, left = 2cm, right = 2cm]{geometry} 
\geometry{a4paper} 
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{graphicx} 
\usepackage{amsmath,amssymb}  
\usepackage{bm}  
\usepackage[pdftex,bookmarks,colorlinks,breaklinks]{hyperref}  
\hypersetup{linkcolor=darkgray,citecolor=black,filecolor=black,urlcolor=black} % black links, for printed output
\usepackage{memhfixc} 
\usepackage{pdfsync}  
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{lmodern}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\pagestyle{fancy}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\title{ArtC++}
\author{
  Archit Ganvir \\
  \texttt{CS21BTECH11005}
  \and
  Kushagra Gupta \\
  \texttt{CS21BTECH11033}
  \and
  Rahul Ramachandran\\
  \texttt{CS21BTECH11049}
  \and
  Suryaansh Jain\\
  \texttt{CS21BTECH11057}
}
\date{}

\begin{document}
\maketitle
\tableofcontents

\section{Introduction}

% Our motivation for designing this language is to provide an easy-to-use language for image manipulation for all the geeky programmers who find camera applications difficult to use. \\
% % In today's age of social media and content creation, there is a high demand for software that can manipulate digital images and videos. This type of software is aimed towards content creation, marketing and advertising, entertainment, image and video compression, etc..\\
% % Inspired by this demand, we have come up with a basic language to manipulate digital images, and also create videos using these images. \\
% We have provided a lot of functionalities such as drawing basic shapes, applying filters to images, compressing images, adding images, composing images into a video played on the terminal, etc.. \\
% We have selected C++ as our target language, and have avoided the use of image manipulation libraries. We aim to provide high-level functions and have also used concepts of object oriented programming to provide a simple and intuitive interface. \\
ArtC++ is a unique image manipulation language that aims to make image editing fun and easy. It borrows inspiration from several languages and libraries like C/C++, Java, Python, NumPy, and Pillow. While it uses types, it supports several inbuilt functions, and behaves similarly to functional programming languages. 
In addition to this, ArtC++ supports several unique features, like printing images to the terminal. The language can also support basic video manipulation, and can play frames of the video in the terminal.

ArtC++ is compiled to C++, ensuring that the code is fast and efficient.

\section{Lexical Specifications}
  \subsection{Keywords}

  \begin{tabular}{ |p{3cm}|p{3cm}|p{3cm}|p{3cm}|p{3cm}| }
    \hline
    img & gray\_img & num & real & and\\
    \hline
    or & spool & presuming & otherwise & break \\
    \hline
    continue & return & ink & void & bool\\
    \hline
    true & false & vid & gray\_vid &\\
    \hline
   \end{tabular}

  \subsection{Identifiers}
  
    As in several other languages, identifiers begin with a letter or underscore, and are followed by a sequence of letters, underscores or digits. Identifiers are case-sensitive. For example :-
   \begin{lstlisting}[language=Python]
    abcdef
    _23n32_
    343491h # Invalid identifier
    *()_  # Invalid identifier\end{lstlisting}


  \subsection{Comments}

  Single-line comments start with a $\#$ symbol. For example :-

  \begin{lstlisting}[]
    # This is a single-line comment\end{lstlisting}

  Multi-line comments are enclosed by $\#*$ and $*\#$. For example :-

  \begin{lstlisting}
    #* This
    is a
    multi-line comment *#\end{lstlisting}

    \subsection{Whitespace}

    As in C++, whitespaces (including tabs and spaces) is ignored. It is however recommended to include them to improve readability. 
    The newline character is however used to define statements, like in Python. Curly braces \{\} are used to define scope. 



\section{Datatypes}
\begin{tabular}{ |p{3cm}|p{10cm}|  }
  \hline
  Data Type & Description\\
  \hline
  \multicolumn{2}{|c|}{Primitive} \\
  \hline
  \texttt{img} & multicolor image \\
  \texttt{gray\_img} & grayscale image \\
  \texttt{num} & \texttt{integer}\\
  \texttt{real} & \texttt{float}\\
  \texttt{bool} & \texttt{bool}\\
  \hline
  \multicolumn{2}{|c|}{Derived} \\
  \hline
  \texttt{vid} & video, an array of images with a fps\\
  \texttt{gray\_vid} & grayscale video, an array of gray\_images with a fps\\
  \texttt{num[]} & array of integers (1D, 2D or 3D)\\
  \texttt{real[]} & array of real numbers (1D, 2D or 3D)\\
  \hline
 \end{tabular}



\section{Operators}
\begin{tabular}{ |p{3cm}|p{5cm}|p{7cm}|  }
  \hline
  Operator & Example & Description\\
  \hline
  \multicolumn{3}{|c|}{Binary Arithmetic} \\
  \hline
  \texttt{+} & \texttt{a + b} & Here, \texttt{a} and \texttt{b} are either numbers (or reals), or have to be of the same image datatype (RGB or Grayscale). The image shapes have to broadcastable. If a value exceeds 255, it is clipped back to 255. In addition to this, \texttt{a} and \texttt{b} can be videos (of the same datatype and fps). If this is done, the frames are concatenated.\\ \hline
  \texttt{-} & \texttt{a - b} & The operands are the same as for \texttt{+}. If a pixel value goes below 0, it is clipped back to 0.\\ \hline
  \texttt{*} & \texttt{a * b} & The operands and behaviour are similar to \texttt{+} \\ \hline
  \texttt{\^} & \texttt{a \^\ b} & \texttt{\^} is used for XORing two images. \\ \hline 
  \hline
  \multicolumn{3}{|c|}{Unary Arithmetic} \\
  \hline
  \texttt{\textasciitilde} & \texttt{\textasciitilde a} & \texttt{a} is an image or a video. This will invert the colors of the image or the video. \\ \hline
  \texttt{-{}-} & \texttt{a-{}-} & \texttt{a} is a number or a real. The post-decrement operator will decrease the value of \texttt{a}. \\ \hline
  \texttt{++} & \texttt{a++} & \texttt{a} is a number or a real. The post-increment operator will increase the value of \texttt{a}. \\ \hline
  \multicolumn{3}{|c|}{Relational and Logical} \\
  \hline
  >, >= & a > b, a >= b &  The greater-than and greater-than or equal-to operate on numbers (or reals), and are defined as in other programming languages \\  \hline
  <, <= & a < b, a <= b & The less-than and less-than or equal-to operators also operate on numbers or reals\\ \hline
  \texttt{and} & $P_1$ \texttt{and} $P_2$ & Here, $P_1$ and $P_2$ are predicates, and equate to true or false.\\ \hline
  \texttt{or} &  $P_1$ \texttt{or} $P_2$ & The \texttt{or} operator also operates on two predicates.\\ \hline
  ! & !$P_1$ & \texttt{!} flips the truth value of the predicate it operates on \\ \hline
  !=, == & $P_1$ == $P_2$, $P_1$ != $P_2$ & == and != are the standard equality and not-equality operators.\\
  \hline
 \end{tabular}




\section{Statements}
    All statements in ArtC++ end with a newline ('$\backslash$n') character. This keeps the code clean, and ensures that every statement is on a separate line.
    \subsection{Declarations}
      \begin{itemize}
        
        \item Numbers:
            \begin{itemize}
              \item \texttt{num num\_name} 
              \begin{itemize}
                \item Declares a 32 bit integer without initializing it.
              \end{itemize}
              \item \texttt{num num\_name = value} 
              \begin{itemize}
                \item Here, \texttt{value} is a 32 bit integer. 
              \end{itemize}
              \item \texttt{num[x] array\_name}
              \begin{itemize}
                \item Declares an array of integers of size \texttt{x}. The array elements are initialized to 0.
              \end{itemize}
              \item \texttt{num[x] array\_name = array\_2}
              \begin{itemize}
                \item Declares an array of integers of size \texttt{x}. The array elements are initialized to the values in \texttt{array\_2}. \texttt{array\_2} must be an array of integers of size \texttt{x}.
              \end{itemize}
              \item \texttt{num[x] array\_name = \{a, b, c, ...\}}   
              \begin{itemize}
                \item Declares an array of integers of size \texttt{x}. The array elements are initialized to the values in the curly braces. The number of elements in the curly braces must be equal to \texttt{x}.
              \end{itemize}      
              \item \texttt{num[x, y] array\_name}
              \begin{itemize}
                \item Declares a 2D array of integers of size \texttt{x} $\times$ \texttt{y}. The array elements are initialized to 0.
              \end{itemize}
              \item \texttt{num[x, y] array\_name = array\_2}
              \begin{itemize}
                \item Declares a 2D array of integers of size \texttt{x} $\times$ \texttt{y}. The array elements are initialized to the values in \texttt{array\_2}. \texttt{array\_2} must be a 2D array of integers of size \texttt{x} $\times$ \texttt{y}.
              \end{itemize}
              \item \texttt{num[x, y] array\_name = \{\{a, b, c, ...\} , \{...\}, ...\}}
              \begin{itemize}
                \item Declares a 2D array of integers of size \texttt{x} $\times$ \texttt{y}. The array elements are initialized to the values in the curly braces. There must be \texttt{x} curly braces, each containing \texttt{y} elements.
              \end{itemize}
            \end{itemize}
            3D arrays, and arrays for floating point numbers are defined similarly.

        \item RGB Images: 
            \begin{itemize}
              \item \texttt{img img\_name<h, w>}
              \begin{itemize}
                \item Here, \texttt{h} is the height of the image and \texttt{w} is the width of the image.
                \item Declaring an image automatically allocates memory for the image, which is stored as a 3D array (height, width, $3$). Each element is initialized to 0 (the image is initially black).
              \end{itemize}
              \item \texttt{img img\_name<h, w, hex\_code>}
              \begin{itemize}
                \item This declaration is similar to the previous one, except for the hex-code. The format of the hex-code is \texttt{'0xRRGGBB'}, where \texttt{RR}, \texttt{GG}, and \texttt{BB} are hexadecimal numbers representing the red, green, and blue components of the color respectively. Every pixel in the image is initialized to this color.
              \end{itemize}
              \item \texttt{img img\_name<'./img.bmp'>}
              \begin{itemize}
                \item Here, \texttt{'./img.bmp'} is the path to the image file. (Only '.bmp' files are supported)
                \item Declaring an image automatically allocates memory for the image, which is stored as a 3D array (height, width, $3$). The corresponding RGB values of the image are stored.
              \end{itemize}
              \item \texttt{img img\_name = expr}
              \begin{itemize}
                \item This combines a declaration and an initialization. \texttt{expr} is an expression that evaluates to an image, and is assigned to \texttt{img\_name}.
              \end{itemize}
            \end{itemize}


        \item Grayscale Images: \texttt{gray\_img img\_name<h, w>}
            Grayscale images are stored as 2D arrays (height, width). The declaration is similar to RGB images.
            \begin{itemize}
              \item \texttt{gray\_img img\_name<h, w>}
              \item \texttt{gray\_img img\_name<h, w, c>} where \texttt{c} is a value from 0 to 255.
              \item \texttt{gray\_img img\_name<'./img.bmp'>}
              \item \texttt{gray\_img img\_name = expr}
            \end{itemize}


        \item RGB Videos (Image Arrays): \texttt{vid vid\_name<h, w, f>} or \texttt{vid vid\_name<h, w>}
            \begin{itemize}
              \item Here, \texttt{h} is the height of each frame, \texttt{w} is the width of each frame, and \texttt{f} is the frame rate in frames per second (fps). It is optional to specify the frame rate, and the default value is $30$.
              \item Declaring a video results in \texttt{vid\_name} being associated with an empty list. The list can be populated with images using operators and methods like \texttt{.append()} (see below).
            \end{itemize}

        \item Grayscale Videos (Grayscale Image Arrays): \texttt{gray\_vid vid\_name<h, w, f>} or \texttt{gray\_vid vid\_name<h, w>}
            \begin{itemize}
              \item This is identical to the declaration of RGB videos, except that each frame is stored as a 2D array (height, width). As before, each element is initialized to 0.
            \end{itemize}
            
      \end{itemize}


    \subsection{Expressions}
    
    Expressions (The \texttt{RHS} of a statement) must always evaluate to a type that is castable to the \texttt{LHS}. \texttt{real} and \texttt{num} are castable to each other and are castable to \texttt{bool} but \texttt{bool} cannot to typecasted to \texttt{num} or \texttt{real}. (\texttt{gray\_img} and \texttt{img}), (\texttt{gray\_vid} and \texttt{vid}) are also castable to each other. When an \texttt{img} is casted to a \texttt{gray\_img}, it is converted to grayscale. Conversely, when a \texttt{gray\_img} is casted to an \texttt{img}, the single color dimension is replicated. Examples of valid expressions are:
    
    \begin{lstlisting}[language=Python]
  # a,b,c are images/gray_images
  a = b + c
  b = (a + c)/2

  a = a or a and b # a, b are real numbers
  b = a++
  a[2] = b[5] - i*i  #* a and b are arrays of nums/reals and i is a num/real. This also works with videos *#
  a.append(b[5])  # a and b are arrays of nums/reals
  a = a >= b # a gets the value 1 or 0\end{lstlisting}

    Some invalid expressions are:

  \begin{lstlisting}[language=Python]
  a = b + c # a is a vid but b is an img

  b = a++ # a is a bool
  a[2] = b[5] - i*i  # b is a vid and a in a num/real array
  a.append(b[5])  # a is an img\end{lstlisting}
  
    \subsection{Loops : spool}

    We have implemented only one type of loop that incorporates both \texttt{for} and \texttt{while} loops, using the keyword \texttt{spool}. The syntax is as follows:-
    \subsubsection*{Type 1}

    
      \begin{lstlisting}[language=Python]
  # Similar to for loops in C++
  spool (initialization expression; condition expression; update expression)
  {
      <body of the loop>
  }
  
  # Example
  spool (num i = 0; i < 10; i++)
  {
      <body of the loop>
  }\end{lstlisting}

      \subsubsection*{Type 2}

      
      \begin{lstlisting}[language=Python]
  spool (predicate) 
  {
      statements
  }

  # Example
  spool (i < 10)
  {
      statements
  }\end{lstlisting}  

    \subsection{Conditionals}

    Conditional statements will follow the following syntax:-
    \begin{lstlisting}[language=Python]
  $(expression) -> {
      statements
  } $$(expression) -> {
      statements
  } -> {
      statements
  }\end{lstlisting}

  The first expression is evaluated, and if it is true, the statements in the first block are executed. If it is false, the next expression is evaluated, and so on. If all the expressions are false, the statements in the last block are executed. The last block is optional. 

\section{Programming Constructs}
    \subsection{Functions}
          \subsubsection{Image Manipulation}
          
          \begin{tabular}{ |p{4cm}|p{5cm}|p{7cm}|  }
            \hline
            \textbf{Action} & \textbf{Example} & \textbf{Description}\\ 
            \hline
            \texttt{blur} & \texttt{a.blur(5)} & Adds a box blur to the image (or blurs every frame of the video). The argument to the method determines the kernel size; the higher it is, the blurrier the image.\\ \hline
            \texttt{sharpen} & \texttt{a.sharpen(20)} & Sharpens the image or frames of the video using the formula \texttt{new\_image = 2* old\_image - blurred\_image}. Increasing the parameter increases the sharpness\\ \hline
            \texttt{sobel filter} & \texttt{a.sobel()} & Uses the sobel operator to find horizontal and vertical edges in the image\\ \hline
            \texttt{transpose} & \texttt{a.T()} & Finds the transpose of the image (equivalent to a 90 degree clockwise rotation)\\ \hline
            \texttt{flipping} & \texttt{a.vflip()} or \texttt{a.hflip()}& Flips the image vertically or horizontally (or every frame of the video) \\ \hline
            \texttt{pixelate} & \texttt{a.pixelate(5)} & Makes the image pixelated, by taking the max value in a grid. The parameter determines the degree of pixelation\\ \hline
            \texttt{invert} & \texttt{a.invert()} & Inverts the colors of the image \\ \hline
            \texttt{noise} & \texttt{a.noise(15)} & Adds random gaussian noise to the image. The parameter governs the variance of the normal distribution \\ \hline
            \texttt{black and white} & \texttt{a.bnw(100)} & Converts the grayscale image \texttt{a} to a black and white image, based on some controllable brightness threshold \\ \hline
            \texttt{pixel manipulation} & \texttt{a.get(x, y, c)} or \texttt{a.set(x, y, color\_hex)} & Gets the pixel value at (x, y, c) or sets the pixel value at (x, y) to the specified color \\ \hline
            \texttt{convolution} & \texttt{a.convolve(f1, f2, f3)} or \texttt{a.convolve(f1)} & This allows the user to implement custom filters. The filter must be a 2 or 3 dimensional array, depending on whether the image is grayscale or RGB. Based on the number 
            of filters (1 or 3), the output is either a grayscale image or an RGB image. \\ \hline
           \end{tabular}

          \subsubsection{Displaying Images and Videos}
            \begin{tabular}{ |p{4cm}|p{5cm}|p{7cm}|  }
                \hline
                \textbf{Method} & \textbf{Example} & \textbf{Description}\\ 
                \hline
                \texttt{paint()} & \texttt{a.paint()} & Displays the image \texttt{a} in the terminal \\ \hline
                \texttt{frame()} & \texttt{a.frame('img.bmp')} & Saves the image \texttt{a} to the specified path (only .bmp) \\ \hline
                \texttt{play()} & \texttt{a.play()} & Plays the video \texttt{a} in the terminal (resolution might be lowered)\\ \hline
             \end{tabular}


          \subsubsection{Other Methods}

          \begin{tabular}{ |p{4cm}|p{5cm}|p{7cm}|  }
            \hline
            \textbf{Method} & \textbf{Example} & \textbf{Description}\\ 
            \hline
            \texttt{len()} & \texttt{a.len()} & Returns the number of frames in video \texttt{a} \\ \hline
            \texttt{append()} & \texttt{a.append(b)} & Appends image \texttt{b} or video \texttt{b} to the video \texttt{a}. The types should match-up \\ \hline
            \texttt{height()} & \texttt{a.height()} & Returns the height of an image or the images in video \texttt{a} \\ \hline
            \texttt{width()} & \texttt{a.width()} & Returns the width of an image or the images in video \texttt{a} \\ \hline
         \end{tabular}
             


          \subsubsection{Drawing on Images}
             \texttt{draw()} is a method that can be used to draw shapes on images. It supports the following shapes :-
             \begin{lstlisting}[language=Python]
  # Draws circle with center (x\_c, y\_c) and radius r on image 'a'
  a.draw('circle', x_c, y_c, r, color_hex)

  # Draws a line from (x1, y1) to (x2, y2) on image 'a'
  a.draw('line', x1, y1, x2, y2, color_hex)

  # Draws a rectangle with center (x\_c, y\_c) and dimensions h and w
  a.draw('rectangle', x_center, y_center, h, w, color_hex)

  # Draws a triangle with vertices (x1, y1), (x2, y2), (x3, y3)
  a.draw('triangle', x1, y1, x2, y2, x3, y3, color_hex)

  # Draws an ellipse with center (x\_c, y\_c) and radii a and b
  a.draw('ellipse', x_center, y_center, a, b, color_hex)\end{lstlisting}

  % TODO: Explain what arguments can be   
          \subsubsection{User-defined Functions}
          The programmer must define a \texttt{ink main()->void} function.
          All user defined functions must have a \texttt{return} statement in them. They must also only return an object of the declared return type.
            \begin{lstlisting}[language=Python]
  ink func_name (parameters)->return_type
  {
      statements
  }\end{lstlisting}
Functions are provided with a comma separated list of parameters, just like in C/C++
  \begin{lstlisting}[language=Python]
  ink func_name (img i1, num a1, vid v1)->return_type
  {
      statements
  }
  \end{lstlisting}

  \subsubsection{Operations on Images}
  ArtC++ overloads several operators to allow for easy manipulation of images. Standard operators like \texttt{+}, \texttt{-}, \texttt{*} and \texttt{/} are supported. The "square root" of images can also be taken. However, consider:
  \begin{lstlisting}[language=Python]
    a = sqrt(b*b + c*c)\end{lstlisting}
  If an overflow happens, and values are clipped to 255, the result might not be what is expected, as all the values of the result will be less than $\sqrt{255}$.  A similar problem occurs with statements like $a = \frac{b + c}{2}$. To avoid this,
  the implementation allows for overflows, and \textit{only} clips the values on assignment, loading, or displaying. This ensures that the result of the above statements are correct and consistent with what is expected.


    \subsection{Slicing}
  We allow the slicing of videos. This returns a new video with the specified frames. The syntax is as follows :-
  \begin{lstlisting}[language=Python]
  a = b[1:10] # This returns a video with frames 1 to 9 of b
  a = b[1:10:2] # This returns a video with frames 1, 3, 5, 7, 9 of b
  a = b[1:] # This returns a video with frames 1 to the end of b\end{lstlisting}



\bibliographystyle{abbrv}

\section{Language Style}
Our language enforces the use of new lines, in an attempt to stick with the Python aphorism: \texttt{Beautiful is better than ugly}.

A newline must follow every statement, including declaration statements, call statements (user-defined and inbuilt), expression statements, return statements,
unary statements, and nested scopes. This helps make the code more readable. In addition to this, newlines must follow a loop block, and a conditional block. Within the conditional block, it isn't necessary to have a newline after a closing curly brace following the body of the conditional.
valid examples are: 
\begin{lstlisting}[language=Python]
  # valid if statement
  $ (i1) -> { 
			i2 = i3
	} 

  <statement>

  
  # another valid if statement 
  $ 

  (i1)
    ->
  {
    <statements>
  } 
  <statement>

  # a third valid conditional block

  $ (i1) -> { 
    <statements>
  } $$ (i2) -> {
    <more statements>
  } -> {
    <even more statements>
  }
  
  # a fourth valid conditonal block

  $ (i1) -> { 
      <statements>
  } 
  $$ (i2) -> {
      <more statements> 
  }
  -> {
      <even more statements>
  } \end{lstlisting}

Some invalid examples are:
\begin{lstlisting}[language=Python]
# invalid if statement
$ (i1) -> { <statement>

}

# invalid if statement 2
$ (i1) -> {
  <statements> 
} $$ (i2) -> {
  <more statements>
} -> {
  <even more statements>
} <statement> #(no newline after closing curly brace)
\end{lstlisting}


% TODO: Change sample programs
\section{Sample Programs}

\subsection*{Example 1}

\begin{lstlisting}[language=Python]
  
  ink bar (img p, img q, img r)->img {
    num h = p.height()
    num w = p.width()
    img s <h, w>
    num a = 2
    real b = 7.8

    presuming (a + b > 10) {
      s = p * (q + r)
    } otherwise presuming (a + b == 10) {
      s = q * (p + r)
    } otherwise {
      s = r * (p + q)
    }
      
    return s
  }

  ink func(img i1, img i2, img i3)->img {
    num i

    spool (i = 0; i < 10; i++) {
      i1 = i1 + i2 * i3
    }

    return i1
  }
  
  ink main()->void {
      img i1.load('./i1.bmp')
      img i2.load('./i2.bmp')
      img i3.load('./i3.bmp')

      i2.draw('rectangle', 50, 40, 50, 40, 0xff0000)
      i2.draw('triangle', 0, 0, 5, 5, 3, 4, 0x00ffff)
  
      i3 = func(bar(i1, i2, i3), i1, i2)
  
      i3.frame('./i_mod.bmp')
  
      i3.paint()
      return
}
\end{lstlisting}


\subsection*{Example 2}


\begin{lstlisting}[language=Python]
  ink foo(img a, img b, img c)->img { 
   img res = a*b + c 
   return res
  }
  
  ink foo1(img a, img b)->img {
      return b*a.blur()
  }
  
  ink main()->void {
      img i1.load('./i1.bmp')
      img i2.load('./i2.bmp')
      img i3.load('./i3.bmp')
  
      i3 = foo1(foo(i1, i2, i3), i1)
  
      i2.draw('circle', 50, 40, 20)
      i2.draw('line', 0, 0, 2, 3)
  
      i2.paint() # displays i2 in the terminal
      i2.frame('./i2_mod.bmp')
  
      i3.frame('./i_res.bmp')
  
      i3.paint() # displays i3 in the terminal
      return
  }
\end{lstlisting}

% \bibliography{references}  % need to put bibtex references in references.bib 
\end{document}